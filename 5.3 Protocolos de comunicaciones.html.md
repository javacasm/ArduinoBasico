## Protocolos de comunicaciones

Vamos a ver en este capítulo diferentes protocolos de comunicaciones usados habitualmente en el mundo de la electrónica y fácilmente usables con arduino. Todas las placas arduino tienen unas patillas capaces de hablar de forma nativa (natural) cada uno de estos protocolos.

Se usará cada uno de ellos dependiendo de la naturaleza del circuito a conectar, pues normalmente estos dispositivos, que actúan como
periféricos de arduino, sólo pueden hablar uno de los protocolos.

Todos los protocolos que vamos a enumerar son protocolos serie, lo que quiere decir que los datos se envían de forma sucesiva por unos pocos hilos. Por oposición se podría hablar de protocolos paralelos en los que se mandan varios datos de forma simultánea.

### I2C
![](https://lh6.googleusercontent.com/dv6KY1JLtHFyJQDwPKu8bywYQ6qadb858uYg-FYa9n4u4zLkwt9gNB6WNf7Ojc2n0d1L1_v8ZGUaZVj0u5wCwmMxrTLxXB9sWC7ML37KgQRSUB3Xj-0)

**i²C** es un bus de comunicaciones en serie. Su nombre viene de Inter-Integrated Circuit (Entre Circuitos****Integrados). La versión 1.0 data del año 1992 y la versión 2.1 del año 2000, su diseñador es gigante fabricante electrónico Philips. La velocidad es de 100Kbits por segundo en el modo estándar, aunque también permite velocidades de 3.4 Mbit/s. 

Es un bus muy usado en la industria, principalmente para comunicar microntroladores y sus periféricos en sistemas integrados (Embedded
Systems) y generalizando más para comunicar circuitos integrados entre si que normalmente residen en un mismo circuito impreso. 


Este tipo de conección se conoce como bus, lo que quiere decir que podemos conectar simultáneamente varios chips compatibles. Para ello la mayoría de los chips que utilizan este protocolo disponen de unos pines que les a**signan una direccion, que será la que se utilice para enviarles datos. En este protocolo existe un maestro (master) que controla la comunicación y varios esclavos (slaves) que responde a sus peticiones.


Los datos se incluyen en un paquete I2C con el siguiente formato:

| start | A7 A6 A5 A4 A3 A2 A1 | R/W | ACK | ... DATA ... | ACK | stop | idle |

Veamos algunos de los dispositivos que incluyen comunicaciones I2C

-   Memorias externas
-   Sensores
-   GPIO (chips que permiten usar más I/O que las que tiene el micro)
-   Potenciómetros
-   ADC (convertidores Analógico a Digital, es decir un circuito que mide un valor analógico y nos da una medida digital)
-   DAC (Convertidor Digital a Analógico, a la inversa que el anterior, dado un valor digital el chip genera en voltaje proporcional al valor dado)
-   .....


La librería Wire es la que permite comunicar con dispositivos I2C (también llamado TWI). En la mayoría de las placas Arduino, SDA
(línea de datos) está en el pin analógico 4, y SCL (línea de reloj) está en el pin analógico 5. En Arduino Mega, SDA esta en el pin digital 20 y SCL en el 21.

#### Funciones

-   [begin](http://arduino.cc/es/Reference/WireBegin)()
-   [begin](http://arduino.cc/es/Reference/WireBegin)(direccion)
-   [requestFrom](http://arduino.cc/es/Reference/WireRequestFrom)(**direccion,**contaje)
-   [beginTransmission](http://arduino.cc/es/Reference/WireBeginTransmission)(direccion)
-   [endTransmission](http://arduino.cc/es/Reference/WireEndTransmission)()
-   [send](http://arduino.cc/es/Reference/WireSend)()
-   byte[available](http://arduino.cc/es/Reference/WireAvailable)()
-   byte[receive](http://arduino.cc/es/Reference/WireReceive)()[](http://arduino.cc/es/Reference/WireOnReceive)
-   [onReceive](http://arduino.cc/es/Reference/WireOnReceive)(handler)**[](http://arduino.cc/es/Reference/WireOnRequest)**
-   **[onRequest](http://arduino.cc/es/Reference/WireOnRequest)(handler)**\


Podéis ver un ejemplo de conexión y de programación en el siguiente [enlace](http://www.hispavila.com/3ds/atmega/i2c-eeprom.html).


### SPI

Se trata de otro bus muy similar al anterior, con la diferencia de que existe una línea de control para cada uno de los nodos
En la imagen siguiente podemos ver la estructura de un bus donde se han conectado 3 nodos. 
![](https://lh4.googleusercontent.com/jXuLm-_RRwXqNrhjO_xjqa-v7-OoInLEEYFuTG0m6H4glONkOPq4r39EioDdU13u68Debvv1P9nXp-_E-B0XlBaGrUtRozY4xUnwu5ah9A1sohqwCDY)

#### Fuciones


-   [begin](http://arduino.cc/en/Reference/SPIBegin)()
-   [end](http://arduino.cc/en/Reference/SPIEnd)()
-   [setBitOrder](http://arduino.cc/en/Reference/SPISetBitOrder)()
-   [setClockDivider](http://arduino.cc/en/Reference/SPISetClockDivider)()
-   [setDataMode](http://arduino.cc/en/Reference/SPISetDataMode)()
-   [transfer](http://arduino.cc/en/Reference/SPITransfer)()


Ejemplos:\

-   Tarjetas SD
-   Módulos Ethernet
-   RTC (Relojes de tiempo real)
-   ...


Arduino ethernet usa el pin 4 para seleccionar la SD y el 11 para la ethernet.[Enlace](http://arduino.cc/en/uploads/Main/arduino-ethernet-schematic.pdf) Podemos ver en el siguiente vídeo como utilizar un chip expansor de salidas (nos da muchas más salidas para usar) que se comunica por protocolo SPI



### Shift Register HC595


Un Shift Register es un chip que permite controlar varias salidas (normalmente 8) por medio de 3 líneas digitales. Además se pueden conectar en cascadas, es decir la salida de uno en la entrada de otro de manera que se puede ampliar el número de conexiones de forma teorícamente ilimitada.

Utilizan un protocolo propio de comunicaciones. Este es el patillaje de un chip HC595, siendo Qx las salidas que puede controlar.

![](https://lh6.googleusercontent.com/Hq8nkB9CnjbkbWpnfi3nVOkrrJBix91rQ34OUoXRl64IwpR5CJpsrAT0-VHWne1dK8VaaXoQ4SThHIwdlBC5pbfhji99WBBDgRowaqD--5O87Rodp5o)\

Veamos un montaje y vídeo de su funcionamiento 
![595](http://ecampus.ugr.es/moodle/draftfile.php/900/user/draft/842052535/595.png "595")\
\


|--------------|---------|----------------------------------------
|PINS 1-7, 15|   Q0 " Q7   |Output Pins
|PIN 8|          GND       |Ground, Vss
|PIN 9|          Q7"       |Serial Out
|PIN 10|         MR        |Master Reclear, active low
|PIN 11|         SH_CP    |Shift register clock pin
|PIN 12|         ST_CP    |Storage register clock pin (latch pin)





### OneWire

Protocolo propietario de Dallas (Maxim-IC) que permite la conexión de dispositivos digitales a través de un único hilo****(y la alimentación claro). Cada uno de los dispositivos dispone de número único guardado en un ROM interna. Este numero determina la familia del dispositivos y sus caracteristicas. 

Además este protocolo dispone de lo que se denomina autodescubrimiento, que no es más que un nodo puede pedir a los demás que se identifiquen.

Sí lo único que vamos a hacer es leer algunos sensores de temperatura podemos usar una librería que nos facilita esta tarea. Se llama "Dallas Temperature" y podemos aprender a usar y descargarla desde esta [dirección](http://milesburton.com/Dallas_Temperature_Control_Library).

En el ejemplo siguiente se usa esta caracteristica para descubrir los 32 sensores de temperatura que hay conectados a una placa Arduino.
